/**
* klarnaPaymentsVCNSettlement.ds
*
* API call to create new Klarna Payments VCN settlement
*
* @input Order : dw.order.Order The SCC Order object
* @input klarnaPaymentsOrderID : String
* @input LocaleObject : dw.object.CustomObject
*/

// import packages
var Logger = require( 'dw/system/Logger' );
var Site = require( 'dw/system/Site' );
var logger = Logger.getLogger( 'klarnaPaymentsVCNSettlement.ds' );
var Transaction = require( 'dw/system/Transaction' );
var StringUtils = require( 'dw/util/StringUtils' );
var KlarnaPayments = {
	httpService 			: require('*/cartridge/scripts/common/KlarnaPaymentsHttpService.ds'),
	apiContext 				: require('*/cartridge/scripts/common/KlarnaPaymentsApiContext')
};

function execute( args : PipelineDictionary ) : Number
{	
	var localeObject = args.LocaleObject;
	var klarnaPaymentsOrderID = args.klarnaPaymentsOrderID;

	try {
		var klarnaPaymentsHttpService = new KlarnaPayments.httpService();
        var klarnaApiContext = new KlarnaPayments.apiContext();
		var requestUrl = klarnaApiContext.getFlowApiUrls().get('vcnSettlement');
		var requestBody = {
			'order_id' : klarnaPaymentsOrderID,
			'key_id' : Site.getCurrent().getCustomPreferenceValue( 'kpVCNkeyId' )
		};
     
		var response = klarnaPaymentsHttpService.call(requestUrl, 'POST', localeObject.custom.credentialID, requestBody);	
		if( empty(response.settlement_id) || empty( response.cards ))
		{
			return PIPELET_ERROR;		
		}
	} catch (e) {
		logger.error(e);
		return PIPELET_ERROR;
	}

	try {
		var Cipher = require( 'dw/crypto/Cipher' );
		var Encoding = require( 'dw/crypto/Encoding' );
		var VCNPrivateKey = Site.getCurrent().getCustomPreferenceValue( 'vcnPrivateKey' );
		var cypher = new Cypher();

		var keyEncryptedBase64 = response.cards[0].aes_key;
		var keyEncryptedBytes = Encoding.fromBase64( keyEncryptedBase64 );
		var keyDecrypted = cipher.decryptBytes( keyEncryptedBytes, VCNPrivateKey, "RSA/ECB/PKCS1PADDING", null, 0 );
		var keyDecryptedBase64 = Encoding.toBase64( keyDecrypted );
		var cardDataEncryptedBase64 = response.cards[0].pci_data;
		var cardDataEncryptedBytes = Encoding.fromBase64( cardDataEncryptedBase64 );
		var cardDecrypted = cipher.decryptBytes( cardDataEncryptedBytes, keyDecryptedBase64, "AES/CTR/NoPadding", response.cards[0].iv, 0 );

		var cardDecryptedUtf8 = decodeURIComponent( cardDecrypted );
		var cardObj = JSON.parse( cardDecryptedUtf8 );
		var expiryDateArr = cardObj.expiry_date.split( "/" );

		Transaction.wrap( function()
		{
			args.Order.custom.kpVCNBrand = response.cards[0].brand;
			args.Order.custom.kpVCNCSC = cardObj.cvv;
			args.Order.custom.kpVCNExpirationMonth = expiryDateArr[0];
			args.Order.custom.kpVCNExpirationYear = expiryDateArr[1];
			args.Order.custom.kpVCNHolder = response.cards[0].holder;
			args.Order.custom.kpVCNPAN = cardObj.pan;
			args.Order.custom.kpIsVCN = true;		
		} );
	} catch (e) {
		logger.error(e);
		return PIPELET_ERROR;
	}
    
    return PIPELET_NEXT;	
}